#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
import threading
import requests
import json
import time
import sys
import os
import logging
from google.protobuf.json_format import MessageToDict, ParseDict
import importlib
import re
import base64
from rclpy.qos import QoSProfile
from std_msgs.msg import String
import subprocess
from rosidl_runtime_py import message_to_ordereddict, get_message_interfaces
from rosidl_runtime_py.utilities import get_message
from rclpy.topic_endpoint_info import TopicEndpointTypeEnum

# Add the parent directory to the path for importing protos
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
# Import the protobuf module - it will be generated by __init__.py if needed
from protos import messages_pb2

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger('algorithm_adaptor')

class AlgorithmAdaptor(Node):
    def __init__(self):
        super().__init__('algorithm_adaptor')
        
        # Get configuration from parameters or environment variables
        self.declare_parameter('meta_simulator_url', os.environ.get('META_SIMULATOR_URL', 'http://meta_simulator:5000'))
        self.declare_parameter('adaptor_id', os.environ.get('ADAPTOR_ID', 'algorithm_adaptor_1'))
        self.declare_parameter('algorithm_topic_prefix', os.environ.get('ALGORITHM_TOPIC_PREFIX', ''))
        self.declare_parameter('poll_interval', float(os.environ.get('POLL_INTERVAL', '0.5')))
        self.declare_parameter('topic_discovery_interval', float(os.environ.get('TOPIC_DISCOVERY_INTERVAL', '5.0')))
        self.declare_parameter('simulator_adaptor_id', os.environ.get('SIMULATOR_ADAPTOR_ID', 'simulator_adaptor_1'))
        self.declare_parameter('use_wildcard_destinations', bool(os.environ.get('USE_WILDCARD_DESTINATIONS', 'False').lower() == 'true'))
        
        # Get parameters
        self.meta_simulator_url = self.get_parameter('meta_simulator_url').value
        self.adaptor_id = self.get_parameter('adaptor_id').value
        self.algorithm_topic_prefix = self.get_parameter('algorithm_topic_prefix').value
        self.poll_interval = self.get_parameter('poll_interval').value
        self.topic_discovery_interval = self.get_parameter('topic_discovery_interval').value
        self.simulator_adaptor_id = self.get_parameter('simulator_adaptor_id').value
        self.use_wildcard_destinations = self.get_parameter('use_wildcard_destinations').value
        
        logger.info(f"Algorithm adaptor configuration:")
        logger.info(f"  meta_simulator_url: {self.meta_simulator_url}")
        logger.info(f"  adaptor_id: {self.adaptor_id}")
        logger.info(f"  simulator_adaptor_id: {self.simulator_adaptor_id}")
        logger.info(f"  use_wildcard_destinations: {self.use_wildcard_destinations}")
        logger.info(f"  poll_interval: {self.poll_interval}")
        logger.info(f"  topic_discovery_interval: {self.topic_discovery_interval}")
        
        # Initialize state
        self.current_time = {'seconds': 0, 'nanoseconds': 0}
        self.registered = False
        self.running = True
        self.timing_data = {}  # message_id -> start_time
        
        # Track subscriptions and publishers - fix naming conflict
        self._topic_subscriptions = {}  # topic_name -> subscription
        self._topic_publishers = {}     # topic_name -> publisher
        self._topic_msg_types = {}      # topic_name -> message_type
        
        # Start topic discovery and create initial subscriptions
        self.discover_timer = self.create_timer(self.topic_discovery_interval, self.discover_topics)
        
        # Start polling thread
        self.poll_thread = threading.Thread(target=self.poll_meta_simulator)
        self.poll_thread.daemon = True
        self.poll_thread.start()
        
        # Register with meta simulator
        self.register_with_meta_simulator()
        
        logger.info(f"Algorithm Adaptor {self.adaptor_id} initialized")
    
    def register_with_meta_simulator(self):
        try:
            response = requests.post(
                f"{self.meta_simulator_url}/register",
                json={'adaptor_id': self.adaptor_id}
            )
            if response.status_code == 200 and response.json().get('success'):
                self.registered = True
                logger.info(f"Registered with meta simulator: {self.adaptor_id}")
            else:
                logger.error(f"Failed to register: {response.text}")
        except Exception as e:
            logger.error(f"Error registering with meta simulator: {str(e)}")
    
    def discover_topics(self):
        """Discover ROS topics and create subscriptions/publishers as needed"""
        try:
            # Get all available topics
            topics_and_types = self.get_topic_names_and_types()
            
            # Filter for algorithm-related topics
            algorithm_topics = [(topic, types) for topic, types in topics_and_types 
                                if topic.startswith(self.algorithm_topic_prefix)]
            
            logger.info(f"Discovered algorithm topics: {algorithm_topics}")
            
            # Count publishers and subscribers for each topic
            pub_counts = {}
            sub_counts = {}
            
            # Get publisher and subscriber counts for each topic individually
            for topic_name, _ in algorithm_topics:
                # Count publishers for this topic
                pub_counts[topic_name] = self.count_publishers(topic_name)
                
                # Count subscribers for this topic
                sub_counts[topic_name] = self.count_subscribers(topic_name)
            
            # Process each algorithm topic
            for topic_name, topic_types in algorithm_topics:
                if not topic_types:
                    continue
                    
                msg_type_str = topic_types[0]  # Use the first type
                
                if topic_name not in self._topic_subscriptions and topic_name not in self._topic_publishers:
                    # Determine if this is an input or output topic based on publisher/subscriber counts
                    # If there are more publishers than subscribers, it's likely an output topic
                    # If there are more subscribers than publishers, it's likely an input topic
                    pub_count = pub_counts.get(topic_name, 0)
                    sub_count = sub_counts.get(topic_name, 0)
                    
                    logger.info(f"Topic {topic_name}: {pub_count} publishers, {sub_count} subscribers")
                    
                    if pub_count > sub_count:
                        # This is likely an output topic, create a subscription
                        self.create_topic_subscription(topic_name, msg_type_str)
                    else:
                        # This is likely an input topic, create a publisher
                        self.create_topic_publisher(topic_name, msg_type_str)
                
        except Exception as e:
            logger.error(f"Error discovering topics: {str(e)}")
    
    def get_message_type(self, type_str):
        """Get a message type from its string representation"""
        try:
            # Parse the message type string (e.g., 'std_msgs/msg/String')
            parts = type_str.split('/')
            if len(parts) < 3:
                return None
                
            pkg_name = parts[0]
            msg_name = parts[-1]
            
            # Import the message module
            mod = importlib.import_module(f"{pkg_name}.msg")
            
            # Get the message class
            msg_class = getattr(mod, msg_name)
            return msg_class
            
        except (ImportError, AttributeError) as e:
            logger.error(f"Failed to import message type {type_str}: {e}")
            return None
    
    def create_topic_subscription(self, topic_name, msg_type_str):
        """Create a subscription for the given topic"""
        try:
            msg_type = self.get_message_type(msg_type_str)
            if not msg_type:
                logger.warning(f"Could not get message type for {topic_name}: {msg_type_str}")
                # Fall back to String if we can't get the type
                msg_type = String
            
            logger.info(f"Creating subscription for {topic_name} with type {msg_type.__name__}")
            
            # Create the subscription
            self._topic_subscriptions[topic_name] = self.create_subscription(
                msg_type,
                topic_name,
                lambda msg, tn=topic_name: self.handle_algorithm_output(msg, tn),
                10
            )
            self._topic_msg_types[topic_name] = msg_type
            
        except Exception as e:
            logger.error(f"Failed to create subscription for {topic_name}: {e}")
    
    def create_topic_publisher(self, topic_name, msg_type_str):
        """Create a publisher for the given topic"""
        try:
            msg_type = self.get_message_type(msg_type_str)
            if not msg_type:
                logger.warning(f"Could not get message type for {topic_name}: {msg_type_str}")
                # Fall back to String if we can't get the type
                msg_type = String
            
            logger.info(f"Creating publisher for {topic_name} with type {msg_type.__name__}")
            
            # Create the publisher
            self._topic_publishers[topic_name] = self.create_publisher(
                msg_type,
                topic_name,
                10
            )
            self._topic_msg_types[topic_name] = msg_type
            
        except Exception as e:
            logger.error(f"Failed to create publisher for {topic_name}: {e}")
    
    def poll_meta_simulator(self):
        while self.running:
            if not self.registered:
                # Try to register again if not registered
                self.register_with_meta_simulator()
                time.sleep(1)
                continue
            
            try:
                # Get a list of topics we're interested in (topics we publish to)
                topics_we_publish_to = list(self._topic_publishers.keys())
                
                # Add topic information to the poll request
                response = requests.post(
                    f"{self.meta_simulator_url}/poll",
                    json={
                        'topics': topics_we_publish_to,
                        'last_update_time': self.current_time
                    }
                )
                
                if topics_we_publish_to:
                    logger.debug(f"Polling for topics: {topics_we_publish_to}")
                
                if response.status_code == 200:
                    data = response.json()
                    if data.get('success'):
                        # Update current time
                        self.current_time = data['state']['current_time']
                        
                        # Process messages if any
                        messages = data.get('messages', [])
                        if messages:
                            logger.info(f"Received {len(messages)} messages to process")
                            for msg in messages:
                                self.process_message(msg)
                        # Log if no messages were received but we're expecting some
                        elif topics_we_publish_to:
                            logger.debug(f"No messages received for topics: {topics_we_publish_to}")
                else:
                    logger.error(f"Failed to poll: {response.text}")
            
            except Exception as e:
                logger.error(f"Error polling meta simulator: {str(e)}")
            
            # Sleep for poll interval
            time.sleep(self.poll_interval)
    
    def process_message(self, message):
        # Process incoming message from meta simulator
        logger.info(f"Processing message: {message.get('message_id')}")
        
        # Check message type and route accordingly
        if 'simulator_state' in message:
            # Forward state to algorithm
            self.forward_state_to_algorithm(message)
        
        # Add other message types as needed
    
    def forward_state_to_algorithm(self, message):
        """Forward simulator state to appropriate algorithm topic"""
        try:
            message_id = message.get('message_id')
            simulator_state = message.get('simulator_state', {})
            
            # Get the frame_id (topic) from the simulator state
            frame_id = simulator_state.get('frame_id', '')
            logger.info(f"Processing state message with frame_id (topic): {frame_id}")
            
            # Try to find a matching publisher based on the frame_id
            target_topic = None
            
            # First, try to find an exact match for the topic name
            if frame_id and frame_id in self._topic_publishers:
                target_topic = frame_id
                logger.info(f"Found exact match for topic: {target_topic}")
            else:
                # If no exact match, try to find a topic with a similar name
                for topic in self._topic_publishers.keys():
                    # Extract the topic name without path
                    topic_name = topic.split('/')[-1] if '/' in topic else topic
                    frame_name = frame_id.split('/')[-1] if '/' in frame_id else frame_id
                    
                    if frame_name and frame_name in topic_name:
                        target_topic = topic
                        logger.info(f"Found related topic: {target_topic} for frame_id: {frame_id}")
                        break
            
            if not target_topic:
                # If still no match, use a generic approach
                for topic in self._topic_publishers.keys():
                    if 'state' in topic.lower() or 'input' in topic.lower() or 'env' in topic.lower():
                        target_topic = topic
                        logger.info(f"Using generic topic: {target_topic}")
                        break
                
                # Last resort - use the first available publisher
                if not target_topic and self._topic_publishers:
                    target_topic = next(iter(self._topic_publishers.keys()))
                    logger.info(f"Using first available topic: {target_topic}")
            
            if not target_topic:
                logger.error("No publishers available to forward state")
                return
            
            logger.info(f"Forwarding state to algorithm topic: {target_topic}")
            
            # Start timing for latency measurement
            start_time = time.time_ns()
            self.timing_data[message_id] = start_time
            
            # Use pickle to deserialize the message directly
            if 'pickled_data_b64' in simulator_state:
                try:
                    import pickle
                    pickled_data_b64 = simulator_state.get('pickled_data_b64', '')
                    pickled_data = base64.b64decode(pickled_data_b64)
                    ros_msg = pickle.loads(pickled_data)
                    
                    # Publish the unpickled message directly
                    self._topic_publishers[target_topic].publish(ros_msg)
                    logger.info(f"Published unpickled message to {target_topic}")
                except Exception as e:
                    logger.error(f"Failed to unpickle message data: {str(e)}")
            else:
                logger.error("No pickled data found in message")
            
        except Exception as e:
            logger.error(f"Error forwarding state to algorithm: {str(e)}")
    
    def send_algorithm_response(self, algorithm_response, topic):
        # Send algorithm response to meta simulator, using topic-based routing
        message = {
            'source_id': self.adaptor_id,
            'topic': topic,  # Use the topic name for routing
            'timestamp': self.current_time,
            'algorithm_response': algorithm_response
        }
        
        try:
            response = requests.post(
                f"{self.meta_simulator_url}/send",
                json=message
            )
            
            if response.status_code == 200 and response.json().get('success'):
                logger.info(f"Sent algorithm response to meta simulator for topic {topic}")
            else:
                logger.error(f"Failed to send algorithm response: {response.text}")
        
        except Exception as e:
            logger.error(f"Error sending algorithm response: {str(e)}")
    
    def handle_algorithm_output(self, msg, topic_name):
        """Handle output message from algorithm"""
        try:
            logger.info(f"Received algorithm output on topic: {topic_name}")
            
            # Pickle the ROS message directly
            import pickle
            pickled_data = pickle.dumps(msg)
            
            # Encode as base64
            b64_data = base64.b64encode(pickled_data).decode('ascii')
            
            # Create the algorithm response
            algorithm_response = {
                'pickled_data_b64': b64_data,
                'msg_type': msg.__class__.__module__ + '.' + msg.__class__.__name__,
                'compute_time_ns': 0,  # Will be calculated
                'status': 'success'
            }
            
            # Try to find the message_id for this response
            # In a real system, you'd need to correlate requests and responses
            message_id = None
            if self.timing_data:
                # Just use the oldest timing entry
                message_id = next(iter(self.timing_data.keys()))
            
            # Calculate compute time if we have timing data
            if message_id in self.timing_data:
                start_time = self.timing_data[message_id]
                algorithm_response['compute_time_ns'] = time.time_ns() - start_time
                del self.timing_data[message_id]
            
            # Send algorithm response to meta simulator
            self.send_algorithm_response(algorithm_response, topic_name)
            
        except Exception as e:
            logger.error(f"Error handling algorithm output: {str(e)}")
    
    def destroy_node(self):
        self.running = False
        if self.poll_thread.is_alive():
            self.poll_thread.join(timeout=1.0)
        super().destroy_node()


def main(args=None):
    rclpy.init(args=args)
    node = AlgorithmAdaptor()
    
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main() 