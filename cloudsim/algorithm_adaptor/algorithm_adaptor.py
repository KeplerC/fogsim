#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
import threading
import requests
import json
import time
import sys
import os
import logging
from google.protobuf.json_format import MessageToDict, ParseDict
import importlib
import re
import base64
from rclpy.qos import QoSProfile
from std_msgs.msg import String
import subprocess
from rosidl_runtime_py import message_to_ordereddict, get_message_interfaces
from rosidl_runtime_py.utilities import get_message

# Add the parent directory to the path for importing protos
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
# Import the protobuf module - it will be generated by __init__.py if needed
from protos import messages_pb2

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger('algorithm_adaptor')

class AlgorithmAdaptor(Node):
    def __init__(self):
        super().__init__('algorithm_adaptor')
        
        # Get configuration from parameters
        self.declare_parameter('meta_simulator_url', 'http://meta_simulator:5000')
        self.declare_parameter('adaptor_id', 'algorithm_adaptor_1')
        self.declare_parameter('algorithm_topic_prefix', '/algorithm/')
        self.declare_parameter('poll_interval', 0.1)  # seconds
        self.declare_parameter('topic_discovery_interval', 5.0)  # seconds
        
        # Get parameters
        self.meta_simulator_url = self.get_parameter('meta_simulator_url').value
        self.adaptor_id = self.get_parameter('adaptor_id').value
        self.algorithm_topic_prefix = self.get_parameter('algorithm_topic_prefix').value
        self.poll_interval = self.get_parameter('poll_interval').value
        self.topic_discovery_interval = self.get_parameter('topic_discovery_interval').value
        
        # Initialize state
        self.current_time = {'seconds': 0, 'nanoseconds': 0}
        self.registered = False
        self.running = True
        self.timing_data = {}  # message_id -> start_time
        
        # Track subscriptions and publishers - fix naming conflict
        self._topic_subscriptions = {}  # topic_name -> subscription
        self._topic_publishers = {}     # topic_name -> publisher
        self._topic_msg_types = {}      # topic_name -> message_type
        
        # Start topic discovery and create initial subscriptions
        self.discover_timer = self.create_timer(self.topic_discovery_interval, self.discover_topics)
        
        # Start polling thread
        self.poll_thread = threading.Thread(target=self.poll_meta_simulator)
        self.poll_thread.daemon = True
        self.poll_thread.start()
        
        # Register with meta simulator
        self.register_with_meta_simulator()
        
        logger.info(f"Algorithm Adaptor {self.adaptor_id} initialized")
    
    def register_with_meta_simulator(self):
        try:
            response = requests.post(
                f"{self.meta_simulator_url}/register",
                json={'adaptor_id': self.adaptor_id}
            )
            if response.status_code == 200 and response.json().get('success'):
                self.registered = True
                logger.info(f"Registered with meta simulator: {self.adaptor_id}")
            else:
                logger.error(f"Failed to register: {response.text}")
        except Exception as e:
            logger.error(f"Error registering with meta simulator: {str(e)}")
    
    def discover_topics(self):
        """Discover ROS topics and create subscriptions/publishers as needed"""
        try:
            # Get all available topics
            topics_and_types = self.get_topic_names_and_types()
            
            # Filter for algorithm-related topics
            algorithm_topics = [(topic, types) for topic, types in topics_and_types 
                                if topic.startswith(self.algorithm_topic_prefix)]
            
            logger.info(f"Discovered algorithm topics: {algorithm_topics}")
            
            # Process each algorithm topic
            for topic_name, topic_types in algorithm_topics:
                if not topic_types:
                    continue
                    
                msg_type_str = topic_types[0]  # Use the first type
                
                if topic_name not in self._topic_subscriptions and topic_name not in self._topic_publishers:
                    # Determine if this is an input or output topic
                    if topic_name.endswith('/out') or topic_name.endswith('/response') or topic_name.endswith('/output'):
                        # This is likely an output topic, create a subscription
                        self.create_topic_subscription(topic_name, msg_type_str)
                    else:
                        # This is likely an input topic, create a publisher
                        self.create_topic_publisher(topic_name, msg_type_str)
                    
        except Exception as e:
            logger.error(f"Error discovering topics: {str(e)}")
    
    def get_message_type(self, type_str):
        """Get a message type from its string representation"""
        try:
            # Parse the message type string (e.g., 'std_msgs/msg/String')
            parts = type_str.split('/')
            if len(parts) < 3:
                return None
                
            pkg_name = parts[0]
            msg_name = parts[-1]
            
            # Import the message module
            mod = importlib.import_module(f"{pkg_name}.msg")
            
            # Get the message class
            msg_class = getattr(mod, msg_name)
            return msg_class
            
        except (ImportError, AttributeError) as e:
            logger.error(f"Failed to import message type {type_str}: {e}")
            return None
    
    def create_topic_subscription(self, topic_name, msg_type_str):
        """Create a subscription for the given topic"""
        try:
            msg_type = self.get_message_type(msg_type_str)
            if not msg_type:
                logger.warning(f"Could not get message type for {topic_name}: {msg_type_str}")
                # Fall back to String if we can't get the type
                msg_type = String
            
            logger.info(f"Creating subscription for {topic_name} with type {msg_type.__name__}")
            
            # Create the subscription
            self._topic_subscriptions[topic_name] = self.create_subscription(
                msg_type,
                topic_name,
                lambda msg, tn=topic_name: self.handle_algorithm_output(msg, tn),
                10
            )
            self._topic_msg_types[topic_name] = msg_type
            
        except Exception as e:
            logger.error(f"Failed to create subscription for {topic_name}: {e}")
    
    def create_topic_publisher(self, topic_name, msg_type_str):
        """Create a publisher for the given topic"""
        try:
            msg_type = self.get_message_type(msg_type_str)
            if not msg_type:
                logger.warning(f"Could not get message type for {topic_name}: {msg_type_str}")
                # Fall back to String if we can't get the type
                msg_type = String
            
            logger.info(f"Creating publisher for {topic_name} with type {msg_type.__name__}")
            
            # Create the publisher
            self._topic_publishers[topic_name] = self.create_publisher(
                msg_type,
                topic_name,
                10
            )
            self._topic_msg_types[topic_name] = msg_type
            
        except Exception as e:
            logger.error(f"Failed to create publisher for {topic_name}: {e}")
    
    def poll_meta_simulator(self):
        while self.running:
            if not self.registered:
                # Try to register again if not registered
                self.register_with_meta_simulator()
                time.sleep(1)
                continue
            
            try:
                response = requests.post(
                    f"{self.meta_simulator_url}/poll",
                    json={
                        'adaptor_id': self.adaptor_id,
                        'last_update_time': self.current_time
                    }
                )
                
                if response.status_code == 200:
                    data = response.json()
                    if data.get('success'):
                        # Update current time
                        self.current_time = data['state']['current_time']
                        
                        # Process messages if any
                        for msg in data.get('messages', []):
                            self.process_message(msg)
                else:
                    logger.error(f"Failed to poll: {response.text}")
            
            except Exception as e:
                logger.error(f"Error polling meta simulator: {str(e)}")
            
            # Sleep for poll interval
            time.sleep(self.poll_interval)
    
    def process_message(self, message):
        # Process incoming message from meta simulator
        logger.info(f"Processing message: {message.get('message_id')}")
        
        # Check message type and route accordingly
        if 'simulator_state' in message:
            # Forward state to algorithm
            self.forward_state_to_algorithm(message)
        
        # Add other message types as needed
    
    def forward_state_to_algorithm(self, message):
        """Forward simulator state to appropriate algorithm topic"""
        try:
            message_id = message.get('message_id')
            simulator_state = message.get('simulator_state', {})
            
            # Find an appropriate publisher
            target_topic = None
            for topic in self._topic_publishers.keys():
                # Try to find a topic that might match the state
                if 'state' in topic.lower() or 'input' in topic.lower():
                    target_topic = topic
                    break
            
            if not target_topic:
                # Just use the first available publisher if no match
                if self._topic_publishers:
                    target_topic = next(iter(self._topic_publishers.keys()))
                else:
                    logger.error("No publishers available to forward state")
                    return
            
            logger.info(f"Forwarding state to algorithm topic: {target_topic}")
            
            # Create message instance
            msg_type = self._topic_msg_types[target_topic]
            ros_msg = msg_type()
            
            # Start timing for latency measurement
            start_time = time.time_ns()
            self.timing_data[message_id] = start_time
            
            # Handle both the legacy and new base64 formats
            if 'state_data_b64' in simulator_state:
                # Base64-encoded data
                try:
                    state_data_b64 = simulator_state.get('state_data_b64', '')
                    json_data = base64.b64decode(state_data_b64).decode('utf-8')
                    state_dict = json.loads(json_data)
                    
                    # Try to set message fields from dict
                    if hasattr(ros_msg, 'data'):
                        if isinstance(ros_msg.data, str):
                            ros_msg.data = json.dumps(state_dict)
                        elif isinstance(ros_msg.data, bytes):
                            ros_msg.data = json_data.encode()
                    else:
                        # For more complex messages, try to recursively set fields
                        for key, value in state_dict.items():
                            if hasattr(ros_msg, key):
                                setattr(ros_msg, key, value)
                except Exception as e:
                    logger.error(f"Failed to parse base64 state data: {e}")
            elif 'state_data' in simulator_state:
                # Legacy format (bytes or string)
                state_data = simulator_state.get('state_data', b'')
                if isinstance(state_data, bytes):
                    try:
                        # Try to convert bytes to dict
                        state_dict = json.loads(state_data.decode('utf-8'))
                        
                        # Try to set message fields from dict
                        if hasattr(ros_msg, 'data'):
                            if isinstance(ros_msg.data, str):
                                ros_msg.data = json.dumps(state_dict)
                            elif isinstance(ros_msg.data, bytes):
                                ros_msg.data = state_data
                        else:
                            # For more complex messages, try to recursively set fields
                            for key, value in state_dict.items():
                                if hasattr(ros_msg, key):
                                    setattr(ros_msg, key, value)
                    except Exception as e:
                        logger.error(f"Failed to parse state data: {e}")
                        # Fallback to setting data field if available
                        if hasattr(ros_msg, 'data'):
                            if isinstance(ros_msg.data, str):
                                ros_msg.data = str(state_data)
                            elif isinstance(ros_msg.data, bytes):
                                ros_msg.data = state_data
            
            # Publish message to algorithm
            self._topic_publishers[target_topic].publish(ros_msg)
            
        except Exception as e:
            logger.error(f"Error forwarding state to algorithm: {str(e)}")
    
    def handle_algorithm_output(self, msg, topic_name):
        """Handle output message from algorithm"""
        try:
            logger.info(f"Received algorithm output on topic: {topic_name}")
            
            # Convert ROS message to dictionary
            try:
                msg_dict = message_to_ordereddict(msg)
            except Exception:
                # Fallback for simple messages
                if hasattr(msg, 'data'):
                    msg_dict = {'data': msg.data}
                else:
                    msg_dict = {'data': str(msg)}
            
            # Convert to JSON and then base64 encode
            json_data = json.dumps(msg_dict)
            b64_data = base64.b64encode(json_data.encode()).decode('ascii')
            
            # Create the algorithm response
            algorithm_response = {
                'response_data_b64': b64_data,
                'compute_time_ns': 0,  # Will be calculated
                'status': 'success'
            }
            
            # Try to find the message_id for this response
            # In a real system, you'd need to correlate requests and responses
            message_id = None
            if self.timing_data:
                # Just use the oldest timing entry
                message_id = next(iter(self.timing_data.keys()))
            
            # Calculate compute time if we have timing data
            if message_id in self.timing_data:
                start_time = self.timing_data[message_id]
                algorithm_response['compute_time_ns'] = time.time_ns() - start_time
                del self.timing_data[message_id]
            
            # Send algorithm response to meta simulator
            self.send_algorithm_response(algorithm_response)
            
        except Exception as e:
            logger.error(f"Error handling algorithm output: {str(e)}")
    
    def send_algorithm_response(self, algorithm_response):
        # Send algorithm response to meta simulator
        message = {
            'source_id': self.adaptor_id,
            'destination_id': 'simulator_adaptor',  # Replace with actual destination
            'timestamp': self.current_time,
            'algorithm_response': algorithm_response
        }
        
        try:
            response = requests.post(
                f"{self.meta_simulator_url}/send",
                json=message
            )
            
            if response.status_code == 200 and response.json().get('success'):
                logger.info(f"Sent algorithm response to meta simulator")
            else:
                logger.error(f"Failed to send algorithm response: {response.text}")
        
        except Exception as e:
            logger.error(f"Error sending algorithm response: {str(e)}")
    
    def destroy_node(self):
        self.running = False
        if self.poll_thread.is_alive():
            self.poll_thread.join(timeout=1.0)
        super().destroy_node()


def main(args=None):
    rclpy.init(args=args)
    node = AlgorithmAdaptor()
    
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main() 