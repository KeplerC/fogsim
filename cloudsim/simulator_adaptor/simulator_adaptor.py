#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
import threading
import requests
import json
from google.protobuf.json_format import MessageToDict, ParseDict
import time
import sys
import os
import logging
from threading import Timer
import importlib
import re
from rclpy.qos import QoSProfile
from std_msgs.msg import String
import subprocess
import base64
from rosidl_runtime_py import message_to_ordereddict, get_message_interfaces
from rosidl_runtime_py.utilities import get_message
from rclpy.topic_endpoint_info import TopicEndpointTypeEnum

# Add the parent directory to the path for importing protos
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
# Import the protobuf module - it will be generated by __init__.py if needed
from protos import messages_pb2

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger('simulator_adaptor')

class SimulatorAdaptor(Node):
    def __init__(self):
        super().__init__('simulator_adaptor')
        
        # Get configuration from parameters
        self.declare_parameter('meta_simulator_url', 'http://meta_simulator:5000')
        self.declare_parameter('adaptor_id', 'simulator_adaptor_1')
        self.declare_parameter('simulator_topic_prefix', '')
        self.declare_parameter('poll_interval', float(os.environ.get('POLL_INTERVAL', '0.1')))  # Get from env var with default 0.1s
        self.declare_parameter('topic_discovery_interval', float(os.environ.get('TOPIC_DISCOVERY_INTERVAL', '5.0')))  # Get from env var
        
        # Get parameters
        self.meta_simulator_url = self.get_parameter('meta_simulator_url').value
        self.adaptor_id = self.get_parameter('adaptor_id').value
        self.simulator_topic_prefix = self.get_parameter('simulator_topic_prefix').value
        self.poll_interval = self.get_parameter('poll_interval').value
        self.topic_discovery_interval = self.get_parameter('topic_discovery_interval').value
        
        # Initialize state
        self.current_time = {'seconds': 0, 'nanoseconds': 0}
        self.registered = False
        self.last_poll_time = 0
        self.running = True
        
        # Track subscriptions and publishers - fix naming conflict
        self._topic_subscriptions = {}  # topic_name -> subscription
        self._topic_publishers = {}     # topic_name -> publisher
        self._topic_msg_types = {}      # topic_name -> message_type
        
        # Start topic discovery and create initial subscriptions
        self.discover_timer = self.create_timer(self.topic_discovery_interval, self.discover_topics)
        
        # Start polling thread
        self.poll_thread = threading.Thread(target=self.poll_meta_simulator)
        self.poll_thread.daemon = True
        self.poll_thread.start()
        
        # Register with meta simulator
        self.register_with_meta_simulator()
        
        logger.info(f"Simulator Adaptor {self.adaptor_id} initialized")
    
    def register_with_meta_simulator(self):
        try:
            response = requests.post(
                f"{self.meta_simulator_url}/register",
                json={'adaptor_id': self.adaptor_id}
            )
            if response.status_code == 200 and response.json().get('success'):
                self.registered = True
                logger.info(f"Registered with meta simulator: {self.adaptor_id}")
            else:
                logger.error(f"Failed to register: {response.text}")
        except Exception as e:
            logger.error(f"Error registering with meta simulator: {str(e)}")
    
    def discover_topics(self):
        """Discover ROS topics and create subscriptions/publishers as needed"""
        try:
            # Get all available topics
            topics_and_types = self.get_topic_names_and_types()
            
            # Filter for simulator-related topics
            simulator_topics = [(topic, types) for topic, types in topics_and_types 
                                if topic.startswith(self.simulator_topic_prefix)]
            
            logger.info(f"Discovered simulator topics: {simulator_topics}")
            
            # Count publishers and subscribers for each topic
            pub_counts = {}
            sub_counts = {}
            
            # Get publisher and subscriber counts for each topic individually
            for topic_name, _ in simulator_topics:
                # Count publishers for this topic
                pub_counts[topic_name] = self.count_publishers(topic_name)
                
                # Count subscribers for this topic
                sub_counts[topic_name] = self.count_subscribers(topic_name)
            
            # Process each simulator topic
            for topic_name, topic_types in simulator_topics:
                if not topic_types:
                    continue
                    
                msg_type_str = topic_types[0]  # Use the first type
                
                if topic_name not in self._topic_subscriptions and topic_name not in self._topic_publishers:
                    # Determine if this is an input or output topic based on publisher/subscriber counts
                    # If there are more publishers than subscribers, it's likely an output topic
                    # If there are more subscribers than publishers, it's likely an input topic
                    pub_count = pub_counts.get(topic_name, 0)
                    sub_count = sub_counts.get(topic_name, 0)
                    
                    logger.info(f"Topic {topic_name}: {pub_count} publishers, {sub_count} subscribers")
                    
                    if pub_count > sub_count:
                        # This is likely an output topic that we should subscribe to
                        self.create_topic_subscription(topic_name, msg_type_str)
                    else:
                        # This is likely an input topic that we should publish to
                        self.create_topic_publisher(topic_name, msg_type_str)
                
        except Exception as e:
            logger.error(f"Error discovering topics: {str(e)}")
    
    def get_message_type(self, type_str):
        """Get a message type from its string representation"""
        try:
            # Parse the message type string (e.g., 'std_msgs/msg/String')
            parts = type_str.split('/')
            if len(parts) < 3:
                return None
                
            pkg_name = parts[0]
            msg_name = parts[-1]
            
            # Import the message module
            mod = importlib.import_module(f"{pkg_name}.msg")
            
            # Get the message class
            msg_class = getattr(mod, msg_name)
            return msg_class
            
        except (ImportError, AttributeError) as e:
            logger.error(f"Failed to import message type {type_str}: {e}")
            return None
    
    def create_topic_subscription(self, topic_name, msg_type_str):
        """Create a subscription for the given topic"""
        try:
            msg_type = self.get_message_type(msg_type_str)
            if not msg_type:
                logger.warning(f"Could not get message type for {topic_name}: {msg_type_str}")
                # Fall back to String if we can't get the type
                msg_type = String
            
            logger.info(f"Creating subscription for {topic_name} with type {msg_type.__name__}")
            
            # Create the subscription
            self._topic_subscriptions[topic_name] = self.create_subscription(
                msg_type,
                topic_name,
                lambda msg, tn=topic_name: self.handle_simulator_message(msg, tn),
                10
            )
            self._topic_msg_types[topic_name] = msg_type
            
        except Exception as e:
            logger.error(f"Failed to create subscription for {topic_name}: {e}")
    
    def create_topic_publisher(self, topic_name, msg_type_str):
        """Create a publisher for the given topic"""
        try:
            msg_type = self.get_message_type(msg_type_str)
            if not msg_type:
                logger.warning(f"Could not get message type for {topic_name}: {msg_type_str}")
                # Fall back to String if we can't get the type
                msg_type = String
            
            logger.info(f"Creating publisher for {topic_name} with type {msg_type.__name__}")
            
            # Create the publisher
            self._topic_publishers[topic_name] = self.create_publisher(
                msg_type,
                topic_name,
                10
            )
            self._topic_msg_types[topic_name] = msg_type
            
        except Exception as e:
            logger.error(f"Failed to create publisher for {topic_name}: {e}")
    
    def poll_meta_simulator(self):
        while self.running:
            if not self.registered:
                # Try to register again if not registered
                self.register_with_meta_simulator()
                time.sleep(1)
                continue
            
            try:
                # Get a list of topics we're interested in - topics we publish to (receive algorithm responses for)
                topics_we_subscribe_to = list(self._topic_publishers.keys())
                
                # Add topic information to the poll request
                response = requests.post(
                    f"{self.meta_simulator_url}/poll",
                    json={
                        'topics': topics_we_subscribe_to,
                        'last_update_time': self.current_time
                    }
                )
                
                if response.status_code == 200:
                    data = response.json()
                    if data.get('success'):
                        # Update current time
                        self.current_time = data['state']['current_time']
                        
                        # Process messages if any
                        for msg in data.get('messages', []):
                            self.process_message(msg)
                        
                        # Log if no messages were received but we're expecting some
                        if not data.get('messages') and topics_we_subscribe_to:
                            logger.debug(f"No messages received for topics: {topics_we_subscribe_to}")
                else:
                    logger.error(f"Failed to poll: {response.text}")
            
            except Exception as e:
                logger.error(f"Error polling meta simulator: {str(e)}")
            
            # Sleep for poll interval
            time.sleep(self.poll_interval)
    
    def process_message(self, message):
        # Process incoming message from meta simulator
        logger.info(f"Processing message: {message.get('message_id')}")
        
        # Check message type and route accordingly
        if 'algorithm_command' in message:
            # Forward command to simulator
            self.forward_command_to_simulator(message)
        elif 'algorithm_response' in message:
            # Forward response to simulator
            self.forward_response_to_simulator(message)
        
        # Add other message types as needed
    
    def forward_command_to_simulator(self, message):
        """Forward command to the appropriate simulator topic"""
        try:
            command_data = message.get('algorithm_command', {})
            
            # Find an appropriate publisher
            target_topic = None
            for topic in self._topic_publishers.keys():
                if 'command' in topic.lower() or 'action' in topic.lower() or 'control' in topic.lower():
                    target_topic = topic
                    break
            
            if not target_topic:
                # Just use the first available publisher if no match
                if self._topic_publishers:
                    target_topic = next(iter(self._topic_publishers.keys()))
                else:
                    logger.error("No publishers available to forward command")
                    return
            
            logger.info(f"Forwarding command to simulator topic: {target_topic}")
            
            # Use pickle to deserialize the message
            if 'pickled_data_b64' in command_data:
                try:
                    import pickle
                    pickled_data_b64 = command_data.get('pickled_data_b64', '')
                    pickled_data = base64.b64decode(pickled_data_b64)
                    ros_msg = pickle.loads(pickled_data)
                    
                    # Publish the unpickled message directly
                    self._topic_publishers[target_topic].publish(ros_msg)
                    logger.info(f"Published unpickled command to {target_topic}")
                except Exception as e:
                    logger.error(f"Failed to unpickle command data: {str(e)}")
            else:
                logger.error("No pickled data found in command")
            
        except Exception as e:
            logger.error(f"Error forwarding command to simulator: {str(e)}")
    
    def forward_response_to_simulator(self, message):
        """Forward response to the appropriate simulator topic"""
        try:
            response_data = message.get('algorithm_response', {})
            
            # Find an appropriate publisher
            target_topic = None
            for topic in self._topic_publishers.keys():
                if 'response' in topic.lower() or 'feedback' in topic.lower() or 'action' in topic.lower():
                    target_topic = topic
                    break
            
            if not target_topic:
                # Just use the first available publisher if no match
                if self._topic_publishers:
                    target_topic = next(iter(self._topic_publishers.keys()))
                else:
                    logger.error("No publishers available to forward response")
                    return
            
            logger.info(f"Forwarding response to simulator topic: {target_topic}")
            
            # Use pickle to deserialize the message
            if 'pickled_data_b64' in response_data:
                try:
                    import pickle
                    pickled_data_b64 = response_data.get('pickled_data_b64', '')
                    pickled_data = base64.b64decode(pickled_data_b64)
                    ros_msg = pickle.loads(pickled_data)
                    
                    # Publish the unpickled message directly
                    self._topic_publishers[target_topic].publish(ros_msg)
                    logger.info(f"Published unpickled response to {target_topic}")
                except Exception as e:
                    logger.error(f"Failed to unpickle response data: {str(e)}")
            else:
                logger.error("No pickled data found in response")
            
        except Exception as e:
            logger.error(f"Error forwarding response to simulator: {str(e)}")
    
    def handle_simulator_message(self, msg, topic_name):
        """Handle message from simulator"""
        try:
            logger.info(f"Received simulator message on topic: {topic_name}")
            
            # Pickle the ROS message directly
            import pickle
            pickled_data = pickle.dumps(msg)
            
            # Create simulator state message - use base64 encoding for binary data
            simulator_state = {
                'timestamp': {
                    'seconds': int(self.get_clock().now().seconds_nanoseconds()[0]),
                    'nanoseconds': int(self.get_clock().now().seconds_nanoseconds()[1])
                },
                'frame_id': topic_name,
                'pickled_data_b64': base64.b64encode(pickled_data).decode('ascii'),
                'msg_type': msg.__class__.__module__ + '.' + msg.__class__.__name__
            }
            
            # Send state to meta simulator
            self.send_simulator_state(simulator_state)
            
        except Exception as e:
            logger.error(f"Error handling simulator message: {str(e)}")
    
    def send_simulator_state(self, simulator_state):
        # Send simulator state to meta simulator, using topic-based routing
        message = {
            'source_id': self.adaptor_id,
            'topic': simulator_state['frame_id'],  # Use the topic name for routing
            'timestamp': self.current_time,
            'simulator_state': simulator_state
        }
        
        try:
            response = requests.post(
                f"{self.meta_simulator_url}/send",
                json=message
            )
            
            if response.status_code == 200 and response.json().get('success'):
                logger.info(f"Sent simulator state to meta simulator for topic {simulator_state['frame_id']}")
            else:
                logger.error(f"Failed to send simulator state: {response.text}")
        
        except Exception as e:
            logger.error(f"Error sending simulator state: {str(e)}")
    
    def destroy_node(self):
        self.running = False
        if self.poll_thread.is_alive():
            self.poll_thread.join(timeout=1.0)
        super().destroy_node()


def main(args=None):
    rclpy.init(args=args)
    node = SimulatorAdaptor()
    
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main() 