#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
import threading
import requests
import json
from google.protobuf.json_format import MessageToDict, ParseDict
import time
import sys
import os
import logging
from threading import Timer
import importlib
import re
from rclpy.qos import QoSProfile
from std_msgs.msg import String
import subprocess
from rosidl_runtime_py import message_to_ordereddict, get_message_interfaces
from rosidl_runtime_py.utilities import get_message

# Add the parent directory to the path for importing protos
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
# Import the protobuf module - it will be generated by __init__.py if needed
from protos import messages_pb2

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger('simulator_adaptor')

class SimulatorAdaptor(Node):
    def __init__(self):
        super().__init__('simulator_adaptor')
        
        # Get configuration from parameters
        self.declare_parameter('meta_simulator_url', 'http://meta_simulator:5000')
        self.declare_parameter('adaptor_id', 'simulator_adaptor_1')
        self.declare_parameter('simulator_topic_prefix', '/simulator/')
        self.declare_parameter('poll_interval', 0.1)  # seconds
        self.declare_parameter('topic_discovery_interval', 5.0)  # seconds
        
        # Get parameters
        self.meta_simulator_url = self.get_parameter('meta_simulator_url').value
        self.adaptor_id = self.get_parameter('adaptor_id').value
        self.simulator_topic_prefix = self.get_parameter('simulator_topic_prefix').value
        self.poll_interval = self.get_parameter('poll_interval').value
        self.topic_discovery_interval = self.get_parameter('topic_discovery_interval').value
        
        # Initialize state
        self.current_time = {'seconds': 0, 'nanoseconds': 0}
        self.registered = False
        self.last_poll_time = 0
        self.running = True
        
        # Track subscriptions and publishers
        self.subscriptions = {}  # topic_name -> subscription
        self.publishers = {}     # topic_name -> publisher
        self.msg_types = {}      # topic_name -> message_type
        
        # Start topic discovery and create initial subscriptions
        self.discover_timer = self.create_timer(self.topic_discovery_interval, self.discover_topics)
        
        # Start polling thread
        self.poll_thread = threading.Thread(target=self.poll_meta_simulator)
        self.poll_thread.daemon = True
        self.poll_thread.start()
        
        # Register with meta simulator
        self.register_with_meta_simulator()
        
        logger.info(f"Simulator Adaptor {self.adaptor_id} initialized")
    
    def register_with_meta_simulator(self):
        try:
            response = requests.post(
                f"{self.meta_simulator_url}/register",
                json={'adaptor_id': self.adaptor_id}
            )
            if response.status_code == 200 and response.json().get('success'):
                self.registered = True
                logger.info(f"Registered with meta simulator: {self.adaptor_id}")
            else:
                logger.error(f"Failed to register: {response.text}")
        except Exception as e:
            logger.error(f"Error registering with meta simulator: {str(e)}")
    
    def discover_topics(self):
        """Discover ROS topics and create subscriptions/publishers as needed"""
        try:
            # Get all available topics
            topics_and_types = self.get_topic_names_and_types()
            
            # Filter for simulator-related topics
            simulator_topics = [(topic, types) for topic, types in topics_and_types 
                                if topic.startswith(self.simulator_topic_prefix)]
            
            logger.info(f"Discovered simulator topics: {simulator_topics}")
            
            # Process each simulator topic
            for topic_name, topic_types in simulator_topics:
                if not topic_types:
                    continue
                    
                msg_type_str = topic_types[0]  # Use the first type
                
                if topic_name not in self.subscriptions and topic_name not in self.publishers:
                    # Determine if this is an input or output topic
                    if topic_name.endswith('/in') or topic_name.endswith('/cmd'):
                        # This is likely an input topic, create a publisher
                        self.create_topic_publisher(topic_name, msg_type_str)
                    else:
                        # This is likely an output topic, create a subscription
                        self.create_topic_subscription(topic_name, msg_type_str)
                    
        except Exception as e:
            logger.error(f"Error discovering topics: {str(e)}")
    
    def get_message_type(self, type_str):
        """Get a message type from its string representation"""
        try:
            # Parse the message type string (e.g., 'std_msgs/msg/String')
            parts = type_str.split('/')
            if len(parts) < 3:
                return None
                
            pkg_name = parts[0]
            msg_name = parts[-1]
            
            # Import the message module
            mod = importlib.import_module(f"{pkg_name}.msg")
            
            # Get the message class
            msg_class = getattr(mod, msg_name)
            return msg_class
            
        except (ImportError, AttributeError) as e:
            logger.error(f"Failed to import message type {type_str}: {e}")
            return None
    
    def create_topic_subscription(self, topic_name, msg_type_str):
        """Create a subscription for the given topic"""
        try:
            msg_type = self.get_message_type(msg_type_str)
            if not msg_type:
                logger.warning(f"Could not get message type for {topic_name}: {msg_type_str}")
                # Fall back to String if we can't get the type
                msg_type = String
            
            logger.info(f"Creating subscription for {topic_name} with type {msg_type.__name__}")
            
            # Create the subscription
            self.subscriptions[topic_name] = self.create_subscription(
                msg_type,
                topic_name,
                lambda msg, tn=topic_name: self.handle_simulator_message(msg, tn),
                10
            )
            self.msg_types[topic_name] = msg_type
            
        except Exception as e:
            logger.error(f"Failed to create subscription for {topic_name}: {e}")
    
    def create_topic_publisher(self, topic_name, msg_type_str):
        """Create a publisher for the given topic"""
        try:
            msg_type = self.get_message_type(msg_type_str)
            if not msg_type:
                logger.warning(f"Could not get message type for {topic_name}: {msg_type_str}")
                # Fall back to String if we can't get the type
                msg_type = String
            
            logger.info(f"Creating publisher for {topic_name} with type {msg_type.__name__}")
            
            # Create the publisher
            self.publishers[topic_name] = self.create_publisher(
                msg_type,
                topic_name,
                10
            )
            self.msg_types[topic_name] = msg_type
            
        except Exception as e:
            logger.error(f"Failed to create publisher for {topic_name}: {e}")
    
    def poll_meta_simulator(self):
        while self.running:
            if not self.registered:
                # Try to register again if not registered
                self.register_with_meta_simulator()
                time.sleep(1)
                continue
            
            try:
                response = requests.post(
                    f"{self.meta_simulator_url}/poll",
                    json={
                        'adaptor_id': self.adaptor_id,
                        'last_update_time': self.current_time
                    }
                )
                
                if response.status_code == 200:
                    data = response.json()
                    if data.get('success'):
                        # Update current time
                        self.current_time = data['state']['current_time']
                        
                        # Process messages if any
                        for msg in data.get('messages', []):
                            self.process_message(msg)
                else:
                    logger.error(f"Failed to poll: {response.text}")
            
            except Exception as e:
                logger.error(f"Error polling meta simulator: {str(e)}")
            
            # Sleep for poll interval
            time.sleep(self.poll_interval)
    
    def process_message(self, message):
        # Process incoming message from meta simulator
        logger.info(f"Processing message: {message.get('message_id')}")
        
        # Check message type and route accordingly
        if 'algorithm_command' in message:
            # Forward command to simulator
            self.forward_command_to_simulator(message)
        
        # Add other message types as needed
    
    def forward_command_to_simulator(self, message):
        """Forward command to the appropriate simulator topic"""
        try:
            command_data = message.get('algorithm_command', {})
            command_type = command_data.get('command_type', '')
            
            # Find an appropriate publisher based on command type
            target_topic = None
            for topic in self.publishers.keys():
                if command_type.lower() in topic.lower():
                    target_topic = topic
                    break
            
            if not target_topic:
                # Just use the first available publisher if no match
                if self.publishers:
                    target_topic = next(iter(self.publishers.keys()))
                else:
                    logger.error("No publishers available to forward command")
                    return
            
            logger.info(f"Forwarding command to simulator topic: {target_topic}")
            
            # Create message instance
            msg_type = self.msg_types[target_topic]
            ros_msg = msg_type()
            
            # Try to populate message fields from command data
            # This is a simple example - in real use, you'd need more sophisticated mapping
            if hasattr(ros_msg, 'data') and isinstance(ros_msg.data, str):
                ros_msg.data = str(command_data)
            elif hasattr(ros_msg, 'data') and isinstance(ros_msg.data, bytes):
                ros_msg.data = command_data.get('command_data', b'')
            
            # Publish message
            self.publishers[target_topic].publish(ros_msg)
            
        except Exception as e:
            logger.error(f"Error forwarding command to simulator: {str(e)}")
    
    def handle_simulator_message(self, msg, topic_name):
        """Handle message from simulator"""
        try:
            logger.info(f"Received simulator message on topic: {topic_name}")
            
            # Convert ROS message to dictionary
            try:
                msg_dict = message_to_ordereddict(msg)
            except Exception:
                # Fallback for simple messages
                if hasattr(msg, 'data'):
                    msg_dict = {'data': msg.data}
                else:
                    msg_dict = {'data': str(msg)}
            
            # Create simulator state message
            simulator_state = {
                'timestamp': {
                    'seconds': int(self.get_clock().now().seconds_nanoseconds()[0]),
                    'nanoseconds': int(self.get_clock().now().seconds_nanoseconds()[1])
                },
                'frame_id': topic_name,
                'state_data': json.dumps(msg_dict).encode()
            }
            
            # Send state to meta simulator
            self.send_simulator_state(simulator_state)
            
        except Exception as e:
            logger.error(f"Error handling simulator message: {str(e)}")
    
    def send_simulator_state(self, simulator_state):
        # Send simulator state to meta simulator
        message = {
            'source_id': self.adaptor_id,
            'destination_id': 'algorithm_adaptor',  # Replace with actual destination
            'timestamp': self.current_time,
            'simulator_state': simulator_state
        }
        
        try:
            response = requests.post(
                f"{self.meta_simulator_url}/send",
                json=message
            )
            
            if response.status_code == 200 and response.json().get('success'):
                logger.info(f"Sent simulator state to meta simulator")
            else:
                logger.error(f"Failed to send simulator state: {response.text}")
        
        except Exception as e:
            logger.error(f"Error sending simulator state: {str(e)}")
    
    def destroy_node(self):
        self.running = False
        if self.poll_thread.is_alive():
            self.poll_thread.join(timeout=1.0)
        super().destroy_node()


def main(args=None):
    rclpy.init(args=args)
    node = SimulatorAdaptor()
    
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main() 