#!/usr/bin/env python3

import threading
import requests
import json
import time
import sys
import os
import logging
import grpc
import subprocess
from concurrent import futures
from google.protobuf.json_format import MessageToDict, ParseDict

# Add the parent directory to the path for importing protos
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
# Import the protobuf module - it will be generated by __init__.py if needed
from protos import messages_pb2

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger('network_simulator_adaptor')

class NetworkSimulatorAdaptor:
    def __init__(self):
        # Get configuration from environment variables
        self.meta_simulator_url = os.environ.get('META_SIMULATOR_URL', 'http://meta_simulator:5000')
        self.adaptor_id = os.environ.get('ADAPTOR_ID', 'network_simulator_adaptor')
        self.poll_interval = float(os.environ.get('POLL_INTERVAL', '0.1'))  # seconds
        self.network_simulator_type = os.environ.get('NETWORK_SIMULATOR_TYPE', 'simple')  # 'simple', 'ns3', etc.
        
        # Initialize state
        self.current_time = {'seconds': 0, 'nanoseconds': 0}
        self.registered = False
        self.running = True
        
        # Initialize network simulator based on type
        self.init_network_simulator()
        
        # Start polling thread
        self.poll_thread = threading.Thread(target=self.poll_meta_simulator)
        self.poll_thread.daemon = True
        self.poll_thread.start()
        
        # Register with meta simulator
        self.register_with_meta_simulator()
        
        logger.info(f"Network Simulator Adaptor {self.adaptor_id} initialized with {self.network_simulator_type} simulator")
    
    def init_network_simulator(self):
        if self.network_simulator_type == 'simple':
            # Simple constant latency simulator
            self.network_simulator = SimpleNetworkSimulator()
        elif self.network_simulator_type == 'ns3':
            # NS3 simulator (placeholder)
            self.network_simulator = NS3NetworkSimulator()
        else:
            logger.error(f"Unknown network simulator type: {self.network_simulator_type}")
            raise ValueError(f"Unknown network simulator type: {self.network_simulator_type}")
    
    def register_with_meta_simulator(self):
        try:
            response = requests.post(
                f"{self.meta_simulator_url}/register",
                json={'adaptor_id': self.adaptor_id}
            )
            if response.status_code == 200 and response.json().get('success'):
                self.registered = True
                logger.info(f"Registered with meta simulator: {self.adaptor_id}")
            else:
                logger.error(f"Failed to register: {response.text}")
        except Exception as e:
            logger.error(f"Error registering with meta simulator: {str(e)}")
    
    def poll_meta_simulator(self):
        while self.running:
            if not self.registered:
                # Try to register again if not registered
                self.register_with_meta_simulator()
                time.sleep(1)
                continue
            
            try:
                response = requests.post(
                    f"{self.meta_simulator_url}/poll",
                    json={
                        'adaptor_id': self.adaptor_id,
                        'last_update_time': self.current_time
                    }
                )
                
                if response.status_code == 200:
                    data = response.json()
                    if data.get('success'):
                        # Update current time
                        self.current_time = data['state']['current_time']
                        
                        # Process messages if any
                        for msg in data.get('messages', []):
                            self.process_message(msg)
                else:
                    logger.error(f"Failed to poll: {response.text}")
            
            except Exception as e:
                logger.error(f"Error polling meta simulator: {str(e)}")
            
            # Sleep for poll interval
            time.sleep(self.poll_interval)
    
    def process_message(self, message):
        # Process incoming message from meta simulator
        logger.info(f"Processing message: {message.get('message_id')}")
        
        # Check if this is a network latency request
        if 'simulate_network' in message and message.get('simulate_network'):
            # Calculate network latency
            source = message.get('source_id', '')
            destination = message.get('destination_id', '')
            message_size = len(json.dumps(message).encode())
            
            latency_ns = self.network_simulator.calculate_latency(source, destination, message_size)
            
            # Create network latency response
            network_latency = {
                'latency_ns': latency_ns,
                'source_node': source,
                'destination_node': destination,
                'packet_size_bytes': message_size
            }
            
            # Send network latency response
            self.send_network_latency(network_latency, message.get('message_id'))
    
    def send_network_latency(self, network_latency, original_message_id):
        # Send network latency to meta simulator
        message = {
            'source_id': self.adaptor_id,
            'destination_id': 'meta_simulator',
            'timestamp': self.current_time,
            'network_latency': network_latency,
            'original_message_id': original_message_id
        }
        
        try:
            response = requests.post(
                f"{self.meta_simulator_url}/send",
                json=message
            )
            
            if response.status_code == 200 and response.json().get('success'):
                logger.info(f"Sent network latency to meta simulator")
            else:
                logger.error(f"Failed to send network latency: {response.text}")
        
        except Exception as e:
            logger.error(f"Error sending network latency: {str(e)}")
    
    def stop(self):
        self.running = False
        if self.poll_thread.is_alive():
            self.poll_thread.join(timeout=1.0)


# Simple network simulator with constant latency
class SimpleNetworkSimulator:
    def __init__(self):
        self.base_latency_ns = 1000000  # 1ms base latency
        self.bandwidth_bps = 1000000000  # 1Gbps
    
    def calculate_latency(self, source, destination, packet_size_bytes):
        # Simple latency model: base_latency + (packet_size / bandwidth)
        transmission_latency_ns = (packet_size_bytes * 8 * 1000000000) // self.bandwidth_bps
        return self.base_latency_ns + transmission_latency_ns


# NS3 network simulator (placeholder)
class NS3NetworkSimulator:
    def __init__(self):
        # This would initialize the NS3 simulator, potentially via a subprocess or API
        logger.info("Initializing NS3 Network Simulator")
        self.ns3_process = None
        self.start_ns3()
    
    def start_ns3(self):
        # This would start the NS3 process
        # Placeholder implementation
        logger.info("Starting NS3 simulation")
        # self.ns3_process = subprocess.Popen(["ns3", "run", "cloudsim-network"])
    
    def calculate_latency(self, source, destination, packet_size_bytes):
        # This would call into the NS3 simulator to calculate latency
        # Placeholder implementation
        logger.info(f"NS3 calculating latency from {source} to {destination} for {packet_size_bytes} bytes")
        # Call into NS3 API or use IPC to get the latency
        return 5000000  # 5ms in nanoseconds
    
    def __del__(self):
        if self.ns3_process:
            self.ns3_process.terminate()
            self.ns3_process.wait()


def main():
    adaptor = NetworkSimulatorAdaptor()
    
    try:
        # Keep the main thread alive
        while adaptor.running:
            time.sleep(1)
    except KeyboardInterrupt:
        pass
    finally:
        adaptor.stop()


if __name__ == '__main__':
    main() 