#!/usr/bin/env python3

import time
import json
import uuid
import threading
from flask import Flask, request, jsonify
from google.protobuf.json_format import MessageToDict, ParseDict
import logging
from concurrent.futures import ThreadPoolExecutor
import sys
import os

# Add the parent directory to the path for importing protos
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
# Import the protobuf module - it will be generated by __init__.py if needed
from protos import messages_pb2

app = Flask(__name__)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger('meta_simulator')

class MetaSimulator:
    def __init__(self):
        self.current_time = {'seconds': 0, 'nanoseconds': 0}
        self.message_queue = {}  # Timestamp -> [messages]
        self.message_store = {}  # message_id -> message
        self.adaptors = set()
        self.lock = threading.RLock()
        self.network_simulator = None  # Will be set to the network simulator adaptor
        self.executor = ThreadPoolExecutor(max_workers=10)
        logger.info("Meta Simulator initialized")
        
    def register_adaptor(self, adaptor_id):
        with self.lock:
            self.adaptors.add(adaptor_id)
            logger.info(f"Registered adaptor: {adaptor_id}")
            return True
    
    def advance_time(self, new_time):
        with self.lock:
            if (new_time['seconds'] > self.current_time['seconds'] or 
                (new_time['seconds'] == self.current_time['seconds'] and 
                 new_time['nanoseconds'] > self.current_time['nanoseconds'])):
                self.current_time = new_time
                logger.info(f"Advanced time to: {self.current_time}")
                return True
            return False
    
    def get_messages_for_time(self, target_time):
        with self.lock:
            messages = []
            for timestamp, msgs in list(self.message_queue.items()):
                ts_secs, ts_nsecs = map(int, timestamp.split('.'))
                if (ts_secs < target_time['seconds'] or 
                    (ts_secs == target_time['seconds'] and ts_nsecs <= target_time['nanoseconds'])):
                    messages.extend(msgs)
                    del self.message_queue[timestamp]
            return messages
    
    def add_message(self, message, delay_ns=0):
        with self.lock:
            # Calculate delivery time
            delivery_time_secs = self.current_time['seconds']
            delivery_time_nsecs = self.current_time['nanoseconds'] + delay_ns
            
            # Handle nanosecond overflow
            if delivery_time_nsecs >= 1000000000:
                delivery_time_secs += delivery_time_nsecs // 1000000000
                delivery_time_nsecs = delivery_time_nsecs % 1000000000
            
            timestamp_key = f"{delivery_time_secs}.{delivery_time_nsecs}"
            
            if timestamp_key not in self.message_queue:
                self.message_queue[timestamp_key] = []
            
            # Store the message
            message_id = str(uuid.uuid4())
            message['message_id'] = message_id
            self.message_store[message_id] = message
            self.message_queue[timestamp_key].append(message_id)
            
            logger.info(f"Scheduled message {message_id} for delivery at {timestamp_key}")
            return message_id
    
    def get_state(self):
        with self.lock:
            state = {
                'current_time': self.current_time,
                'pending_messages': len(sum(self.message_queue.values(), [])),
                'registered_adaptors': list(self.adaptors)
            }
            return state
            
    def get_pending_messages_for_topics(self, topics, last_update_time=None):
        """Get messages for the given topics"""
        with self.lock:
            messages = []
            message_ids = self.get_messages_for_time(self.current_time)
            
            for msg_id in message_ids:
                if msg_id in self.message_store:
                    message = self.message_store[msg_id]
                    
                    # Check if the message contains a simulator state with a matching topic
                    if 'simulator_state' in message:
                        simulator_state = message.get('simulator_state', {})
                        topic = simulator_state.get('frame_id', '')  # The topic is stored in frame_id
                        
                        # If the topic matches any of the requested topics, include the message
                        if topic in topics:
                            messages.append(message)
                            logger.info(f"Message {msg_id} matches requested topic: {topic}")
                    
                    # Check for algorithm responses for requested topics
                    elif 'algorithm_response' in message and 'topic' in message:
                        topic = message.get('topic', '')
                        
                        if topic in topics:
                            messages.append(message)
                            logger.info(f"Message {msg_id} matches requested topic (algorithm response): {topic}")
                    
                    # Also include messages with a wildcard topic - useful for broadcast messages
                    elif 'topic' in message and message['topic'] == '*':
                        messages.append(message)
                        logger.info(f"Message {msg_id} is a broadcast message")
                        
            return messages

# Initialize the simulator
simulator = MetaSimulator()

@app.route('/register', methods=['POST'])
def register():
    data = request.json
    adaptor_id = data.get('adaptor_id')
    if not adaptor_id:
        return jsonify({'error': 'Missing adaptor_id'}), 400
    
    success = simulator.register_adaptor(adaptor_id)
    return jsonify({'success': success, 'adaptor_id': adaptor_id})

@app.route('/send', methods=['POST'])
def send_message():
    message_data = request.json
    source_id = message_data.get('source_id')
    topic = message_data.get('topic')
    
    if not source_id or not topic:
        return jsonify({'error': 'Missing source_id or topic'}), 400
    
    # If this is a message that needs network simulation
    if message_data.get('simulate_network', False):
        # Calculate network delay (would call network simulator adapter)
        network_delay_ns = 0  # This would come from network simulator
        message_data['network_delay_ns'] = network_delay_ns
    
    message_id = simulator.add_message(message_data)
    return jsonify({'success': True, 'message_id': message_id})

@app.route('/poll', methods=['POST'])
def poll():
    data = request.json
    topics = data.get('topics', [])
    last_update_time = data.get('last_update_time', simulator.current_time)
    
    state = simulator.get_state()
    if not topics:
        return jsonify({
        'success': True,
        'state': state,
        'messages': []
    })
    
    messages = simulator.get_pending_messages_for_topics(topics, last_update_time)
    
    
    return jsonify({
        'success': True,
        'state': state,
        'messages': messages
    })

@app.route('/advance', methods=['POST'])
def advance():
    data = request.json
    new_time = data.get('time')
    
    if not new_time:
        return jsonify({'error': 'Missing time'}), 400
    
    success = simulator.advance_time(new_time)
    return jsonify({
        'success': success,
        'current_time': simulator.current_time
    })

@app.route('/state', methods=['GET'])
def get_state():
    return jsonify({
        'success': True,
        'state': simulator.get_state()
    })

@app.route('/', methods=['GET'])
def home():
    return jsonify({
        'status': 'running',
        'version': '1.0',
        'registered_adaptors': list(simulator.adaptors),
        'current_time': simulator.current_time
    })

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=False)